
function results = run_star_tdma(varargin)
% run_star_tdma - Star topology PUF-CSK/CDMA simulator with authentication, adversaries,
% multi-user CDMA, broadcast/per-user challenges, optional channel-factor for replay,
% optional challenge preamble reliability, and NONCE freshness (fixed-length).
%
% Features:
%   • Legitimate performance: BER, FAR, FRR, per-slot success, CRPs/slot
%   • True impostor FAR (wrong PUF, naive adversary) with its OWN link SNR
%   • Replay adversary with CAPTURE SNR (eavesdrop) and REPLAY SNR (uplink)
%   • Replay metrics:
%       - CONDITIONAL Replay FAR  = accepted_replays / replay_trials
%       - OVERALL  Replay Risk    = accepted_replays / total_slots
%   • CDMA-only: K_users_per_slot simultaneous transmissions with optional SIC
%   • Challenge mode: 'per-user' (default) or 'broadcast' (same C for all users in a slot)
%   • Optional channel factor (2FA): AND gate on replay via channel-feature similarity
%   • Optional challenge preamble reliability: slot can fail before data
%   • Nonce freshness via Mix(C_seed, U) keeping challenge_len unchanged
%
% Key Name-Value args:
%   'scheme'              : 'CSK' or 'CDMA'  (default 'CDMA')
%   'N'                   : number of nodes (default 8)
%   'M'                   : CSK symbols (power of 2, <= L) (default 16)
%   'L'                   : spreading length / chips per symbol (power of 2) (default 128)
%   'SNRdB_vec'           : vector of SNRs to sweep (default -25:5:10)
%   'bits_per_slot'       : payload bits per slot (default 128)
%   'frames'              : Monte Carlo frames per SNR (default 50)
%   'threshold'           : per-bit/per-symbol confidence threshold (0..1) (default 0.8)
%   'accept_ratio'        : slot-level vote requirement (0..1) (default 0.8)
%   'challenge_len'       : PUF challenge length (bits) (default 64)
%   'puf_bits'            : #bits generated by PUF per query when not using seed expansion (default 128)
%   'crps_per_node'       : size of factory-enrolled CRP table per node (default 256)
%   'use_seed_expansion'  : true uses C to expand into R of needed length, else query PUF per need (default true)
%   'use_node_variation'  : per-node SNR offsets (default false)
%   'node_snr_sigma_db'   : stddev for per-node SNR offsets (default 8)
%   'use_node_similarity' : build similar PUFs per alpha (default false)
%   'similarity_alpha'    : 0..1 similarity (default 0.7)
%   'compute_impostor_far': include naive impostor tests (default true)
%   'compute_replay_far'  : include replay adversary tests (default true)
%   'replay_reuse_prob'   : P(reuse a past effective challenge in slot) in [0,1] (default 0.0)
%   'replay_capture_snr_db'   : SNR(dB) when attacker records (NaN => offset from node SNR)
%   'replay_capture_offset_db': Offset from node SNR for capture SNR (default -6)
%   'impostor_snr_db'         : SNR(dB) for true impostor transmit (NaN => offset from node SNR)
%   'impostor_snr_offset_db'  : Offset from node SNR for impostor SNR (default -3)
%   % Multiuser CDMA knobs
%   'K_users_per_slot'    : # simultaneous CDMA users per slot (default 1)
%   'use_equal_power'     : if false, draw near–far amplitudes (default true)
%   'power_sigma_db'      : near–far stddev in dB if unequal power (default 6)
%   'use_sic'             : enable successive interference cancellation (default false)
%   'cdma_codebook'       : 'puf-random' (default) | 'walsh-orth'
%   'use_slot_dither'     : (default true) keep orthogonality while salting rows
%   % Challenge nonce knobs
%   'use_nonce'           : enable nonce freshness (default true)
%   'nonce_len'           : nonce length in bits (default 64)
%   'nonce_scope'         : 'per-user' (default) or 'broadcast' (slot shared)
%   % Misc
%   'challenge_mode'      : 'per-user' (default) or 'broadcast'
%   'use_channel_factor'  : if true, AND replay decision with channel-sim score (default false)
%   'tau_h'               : channel similarity threshold (default 0.7)
%   'coherence_prob'      : prob. channel CHANGES between capture and replay (default 1.0)
%   'use_challenge_preamble' : if true, preamble can fail; FRR++ and skip data (default false)
%   'preamble_len'        : preamble length in bits (default 32)
%   'preamble_req_snr_db' : reference SNR(dB) for ~good preamble (default 0)
%   'log_level'           : 0(silent)/1(default)/2(verbose)
%   'rng_seed'            : RNG seed for reproducibility (default 1337)
%
% Returns a struct with per-SNR vectors:
%   results.BER, results.FAR, results.FRR, results.AuthSuccess, results.CRPsPerSlot
%   results.FAR_impostor, results.FAR_replay (conditional), results.ReplayOverall (overall)
%   results.replay_opportunities, results.replay_trials
%   results.mean_overlap_R, results.perm_collision_rate (CSK only)
%   results.config, results.node_offsets_dB
%
% Dependencies: make_nodes.m, txrx_cdma_node.m, txrx_csk_node.m,
%   metrics_update.m, get_puf_bits.m, perm_from_bits.m,
%   decide_cdma_legit.m (embedded below), decide_csk_legit.m (embedded below).

    % --- Parse inputs
    p = inputParser;
    addParameter(p,'N',8);
    addParameter(p,'scheme','CDMA'); % 'CSK' or 'CDMA'
    addParameter(p,'M',16);
    addParameter(p,'L',128);
    addParameter(p,'SNRdB_vec',-25:5:10);
    addParameter(p,'bits_per_slot',128);
    addParameter(p,'frames',50);
    addParameter(p,'threshold',0.8);
    addParameter(p,'accept_ratio',0.8);
    addParameter(p,'challenge_len',64);
    addParameter(p,'puf_bits',128);
    addParameter(p,'crps_per_node',256);
    addParameter(p,'use_seed_expansion',true);
    addParameter(p,'use_node_variation',false);
    addParameter(p,'node_snr_sigma_db',8);
    addParameter(p,'use_node_similarity',false);
    addParameter(p,'similarity_alpha',0.7);
    addParameter(p,'compute_impostor_far',true);
    addParameter(p,'compute_replay_far',true);
    addParameter(p,'replay_reuse_prob',0.0);  % freshness by default
    addParameter(p,'replay_capture_snr_db', NaN);
    addParameter(p,'replay_capture_offset_db', -6);
    addParameter(p,'impostor_snr_db', NaN);
    addParameter(p,'impostor_snr_offset_db', -3);
    % Multiuser CDMA knobs
    addParameter(p,'K_users_per_slot',1);
    addParameter(p,'use_equal_power',true);
    addParameter(p,'power_sigma_db',6);
    addParameter(p,'use_sic',false);
    addParameter(p,'cdma_codebook','puf-random');
    addParameter(p,'use_slot_dither',true);
    % Nonce knobs
    addParameter(p,'use_nonce',true);
    addParameter(p,'nonce_len',64);
    addParameter(p,'nonce_scope','per-user');  % 'per-user' | 'broadcast'
    % Other knobs
    addParameter(p,'challenge_mode','per-user');        % 'per-user' | 'broadcast'
    addParameter(p,'use_channel_factor',false);
    addParameter(p,'tau_h',0.7);
    addParameter(p,'coherence_prob',1.0);
    addParameter(p,'use_challenge_preamble',false);
    addParameter(p,'preamble_len',32);
    addParameter(p,'preamble_req_snr_db',0);
    addParameter(p,'log_level',1);
    addParameter(p,'rng_seed',1337);

    parse(p,varargin{:});
    cfg = p.Results;

    % --- Basic checks
    if strcmpi(cfg.scheme,'CSK')
        assert(cfg.M <= cfg.L, 'CSK requires M <= L.');
        assert(abs(log2(cfg.M) - round(log2(cfg.M))) < 1e-9, 'M must be a power of two.');
        assert(abs(log2(cfg.L) - round(log2(cfg.L))) < 1e-9, 'L must be a power of two.');
        assert(mod(cfg.bits_per_slot, log2(cfg.M)) == 0, 'bits_per_slot must be a multiple of log2(M).');
    else
        assert(abs(log2(cfg.L) - round(log2(cfg.L))) < 1e-9, 'L must be a power of two.');
    end

    % --- RNG
    rng(cfg.rng_seed);

    % --- Build nodes (factory enrollment)
    nodes = make_nodes(cfg.N, cfg.challenge_len, cfg.puf_bits, cfg.crps_per_node, ...
                       cfg.use_node_similarity, cfg.similarity_alpha);

    % --- Per-node SNR offsets
    if cfg.use_node_variation
        rng(4242);
        node_offsets = cfg.node_snr_sigma_db * randn(1, cfg.N);
        node_offsets = max(min(node_offsets, 20), -20);
        rng(cfg.rng_seed);
    else
        node_offsets = zeros(1, cfg.N);
    end

    % --- Allocate results
    K = numel(cfg.SNRdB_vec);
    results = struct();
    fields = {'BER','FAR','FRR','AuthSuccess','CRPsPerSlot','FAR_impostor',...
              'FAR_replay','ReplayOverall','mean_overlap_R','perm_collision_rate'};
    for f = 1:numel(fields), results.(fields{f}) = zeros(1,K); end
    results.replay_opportunities = zeros(1,K);
    results.replay_trials = zeros(1,K);
    results.node_offsets_dB = node_offsets;
    results.config = cfg;

    % === Sweep SNR points
    for k = 1:K
        SNRdB = cfg.SNRdB_vec(k);

        % Reset per-SNR state: replay DB & per-node past EFFECTIVE challenges
        replay_db = containers.Map('KeyType','char','ValueType','any');
        past_Ceff = cell(1, cfg.N);

        % Accumulators
        metrics = [];
        overlap_sum = 0; overlap_count = 0;
        perm_collisions = 0; perm_count = 0;
        impostor_accept = 0; impostor_trials = 0;
        replay_accept = 0; replay_trials = 0;
        replay_ops = 0;

        % --- Frames and slots
        for f = 1:cfg.frames
            for s = 1:cfg.N   % TDMA slots across a "frame"

                % === MULTIUSER-IN-A-SLOT (CDMA only) ===
                if strcmpi(cfg.scheme,'CDMA') && cfg.K_users_per_slot > 1
                    % Pick up to K distinct users
                    Keff = min(cfg.K_users_per_slot, cfg.N);
                    slot_users = randperm(cfg.N, Keff);

                    % Optional broadcast challenge for the slot
                    C_shared = [];
                    if strcmpi(cfg.challenge_mode,'broadcast')
                        i0 = slot_users(1);
                        r0 = mod(f-1, size(nodes(i0).CRP_C,1)) + 1;
                        C_shared = nodes(i0).CRP_C(r0, :);
                    end

                    % Optional broadcast nonce for the slot
                    U_shared = [];
                    if cfg.use_nonce && strcmpi(cfg.nonce_scope,'broadcast')
                        U_shared = randi([0,1], 1, cfg.nonce_len);
                    end

                    % Per-user power
                    if cfg.use_equal_power
                        a = ones(1, Keff);
                    else
                        a = 10.^((cfg.power_sigma_db * randn(1, Keff))/20);
                        a = a / norm(a) * sqrt(Keff);
                    end

                    % --- Preamble (challenge phase) modeling
                    if cfg.use_challenge_preamble
                        % For broadcast: one preamble; for per-user: all must succeed
                        preamble_ok = true;
                        if ~isempty(C_shared)
                            SNR_slot = SNRdB + mean(node_offsets(slot_users));
                            preamble_ok = preamble_success(SNR_slot, cfg.preamble_len, cfg.preamble_req_snr_db);
                        else
                            for uu = 1:numel(slot_users)
                                iusr = slot_users(uu);
                                SNR_node_dB = SNRdB + node_offsets(iusr);
                                preamble_ok = preamble_ok && preamble_success(SNR_node_dB, cfg.preamble_len, cfg.preamble_req_snr_db);
                            end
                        end
                        if ~preamble_ok
                            % count one FRR (slot failure) and move on
                            rx_bits = zeros(1, cfg.bits_per_slot);
                            FAR=0; FRR=1; success=false; crps_used=0;
                            metrics = metrics_update(metrics, rx_bits, rx_bits, FAR, FRR, success, crps_used);
                            continue;
                        end
                    end

                    composite = zeros(1, cfg.bits_per_slot * cfg.L);
                    per_user = struct('i',{},'C_eff',{},'tx_bits',{},'spread',{},'amp',{},'SNRdB',{});
                    to_store = struct('key',{},'entry',{});  % defer capture commit

                    % Build per-user waveforms and mix
                    H = hadamard(cfg.L);            % for walsh-orth
                    used_rows = false(1, cfg.L);
                    % Slot-wide dither
                    slot_dither = ones(1, cfg.L);
                    if cfg.use_slot_dither
                        seed_bits = [];
                        if ~isempty(C_shared), seed_bits = [seed_bits, C_shared]; end
                        if ~isempty(U_shared), seed_bits = [seed_bits, U_shared]; end
                        if isempty(seed_bits)
                            seed_bits = [dec2bin(mod(f,1024)) dec2bin(mod(s,1024))] - '0';
                        end
                        mask_d = prg_from_nonce(seed_bits, cfg.L);
                        slot_dither = 2*double(mask_d) - 1;
                    end

                    for uu = 1:numel(slot_users)
                        iusr = slot_users(uu);
                        node = nodes(iusr);

                        % Select EFFECTIVE challenge
                        reuse_pair = (rand < cfg.replay_reuse_prob) && ~isempty(past_Ceff{iusr});
                        if reuse_pair
                            pick = randi(numel(past_Ceff{iusr})); 
                            C_eff = past_Ceff{iusr}{pick}; 
                            replay_ops = replay_ops + 1;
                        else
                            if ~isempty(C_shared)
                                C_seed = C_shared;
                            else
                                r = mod(f-1, size(node.CRP_C,1)) + 1; 
                                C_seed = node.CRP_C(r, :);
                            end
                            if cfg.use_nonce
                                if ~isempty(U_shared)
                                    U = U_shared;
                                else
                                    U = randi([0,1], 1, cfg.nonce_len);
                                end
                                C_eff = mix_challenge_nonce(C_seed, U, cfg.challenge_len);
                            else
                                C_eff = C_seed;
                            end
                        end
                        past_Ceff{iusr}{end+1} = C_eff;

                        tx_bits_u = randi([0,1], 1, cfg.bits_per_slot);

                        % Build spread
                        if strcmpi(cfg.cdma_codebook,'walsh-orth')
                            h = double(hash_bits_u32(C_eff));
                            row0 = 1 + mod(h, cfg.L);
                            step = 1 + mod(bitxor(uint32(h), 2654435761), uint32(cfg.L-1));
                            row = row0; tries = 0;
                            while used_rows(row) && tries < cfg.L
                                row = 1 + mod(row-1 + double(step), cfg.L);
                                tries = tries + 1;
                            end
                            used_rows(row) = true;
                            spread = slot_dither .* H(row, :);
                        else
                            R = get_puf_bits(node, C_eff, cfg.L);
                            spread = 2*R - 1;
                        end

                        % Mix into composite
                        for bb = 1:cfg.bits_per_slot
                            idx = (bb-1)*cfg.L + (1:cfg.L);
                            composite(idx) = composite(idx) + a(uu) * (2*tx_bits_u(bb)-1) .* spread;
                        end

                        per_user(uu).i       = iusr;
                        per_user(uu).C_eff   = C_eff;
                        per_user(uu).tx_bits = tx_bits_u;
                        per_user(uu).spread  = spread;
                        per_user(uu).amp     = a(uu);
                        per_user(uu).SNRdB   = SNRdB + node_offsets(iusr);

                        % Prepare CAPTURED template (defer commit)
                        if cfg.compute_replay_far
                            key_tmp = make_key(iusr, C_eff);
                            if ~isKey(replay_db, key_tmp)
                                if strcmpi(cfg.cdma_codebook,'walsh-orth')
                                    tmpl_clean = build_cdma_template_from_spread(spread, tx_bits_u, cfg.L);
                                else
                                    tmpl_clean = build_cdma_template(node, C_eff, tx_bits_u, cfg.L);
                                end
                                captureSNRdB = decide_capture_snr(per_user(uu).SNRdB, cfg.replay_capture_snr_db, cfg.replay_capture_offset_db);
                                tmpl_captured = add_awgn(tmpl_clean, captureSNRdB);
                                entry = struct('scheme','CDMA','node',iusr,'C',C_eff,'L',cfg.L, ...
                                               'tx_bits',tx_bits_u,'template',tmpl_captured);
                                to_store(end+1).key = key_tmp;
                                to_store(end).entry = entry;
                            end
                        end
                    end

                    % Add AWGN to the composite (slot baseline SNR)
                    slot_power  = mean(abs(composite).^2);
                    noise_power = slot_power / (10^(SNRdB/10));
                    noise       = sqrt(noise_power/2) * randn(size(composite));
                    rx_slot     = composite + noise;

                    % Decode each user (MF; optional SIC)
                    residual = rx_slot;
                    decode_order = 1:numel(per_user);
                    if cfg.use_sic
                        [~, decode_order] = sort([per_user.amp].^2, 'descend'); % strongest-first
                    end

                    for kk = 1:numel(decode_order)
                        uu = decode_order(kk);
                        u  = per_user(uu);

                        % --- Snapshot residual BEFORE canceling user u (for legit decision under SIC)
                        residual_pre_u = residual;

                        rx_bits_u = zeros(1, cfg.bits_per_slot);
                        for bb = 1:cfg.bits_per_slot
                            idx = (bb-1)*cfg.L + (1:cfg.L);
                            seg = residual(idx);
                            corr = sum(seg .* u.spread);
                            rx_bits_u(bb) = (corr > 0);

                            if cfg.use_sic
                                bit_hat = 2*rx_bits_u(bb) - 1;
                                residual(idx) = residual(idx) - u.amp * bit_hat * u.spread;
                            end
                        end

                        % --- Unified CDMA slot decision (Fix: use pre-cancel residual for SIC, raw slot otherwise)
                        if cfg.use_sic
                            rx_for_decision = residual_pre_u;  % contains u's contribution
                        else
                            rx_for_decision = rx_slot;         % no SIC: raw mixture
                        end
                        [slot_accept, ~] = decide_cdma_legit(rx_for_decision, u.spread, u.tx_bits, cfg.L, cfg.threshold, cfg.accept_ratio);

                        FAR = 0; 
                        FRR = double(~slot_accept);
                        success = all(rx_bits_u == u.tx_bits);
                        crps_used = 1;
                        metrics = metrics_update(metrics, rx_bits_u, u.tx_bits, FAR, FRR, success, crps_used);

                        % True impostor FAR
                        if cfg.compute_impostor_far
                            SNR_imp = decide_impostor_snr(u.SNRdB, cfg.impostor_snr_db, cfg.impostor_snr_offset_db);
                            obs = struct('L',cfg.L,'Nbits',cfg.bits_per_slot,'tx_bits',u.tx_bits);
                            [acc, trials] = impostor_cdma_vote(nodes, u.i, u.C_eff, obs, cfg.threshold, cfg.accept_ratio, SNR_imp);
                            impostor_accept = impostor_accept + acc;
                            impostor_trials = impostor_trials + trials;
                        end

                        % Replay adversary (conditional) for this user
                        if cfg.compute_replay_far
                            key_chk = make_key(u.i, u.C_eff);
                            if isKey(replay_db, key_chk)
                                attack = replay_db(key_chk);
                                if isequal(attack.C, u.C_eff)
                                    spread_override = [];
                                    if strcmpi(cfg.cdma_codebook,'walsh-orth')
                                        spread_override = u.spread;
                                    end
                                    slot_accept_r = verify_cdma_replay_cf(nodes(u.i), u.C_eff, attack.template, u.tx_bits, ...
                                                                cfg.L, u.SNRdB, cfg.threshold, cfg.accept_ratio, ...
                                                                cfg.use_channel_factor, cfg.tau_h, cfg.coherence_prob, spread_override);
                                    replay_trials = replay_trials + 1;
                                    if slot_accept_r, replay_accept = replay_accept + 1; end
                                end
                            end
                        end
                    end

                    % Commit captures AFTER replay checks (prevent same-slot replay)
                    for t = 1:numel(to_store)
                        if ~isKey(replay_db, to_store(t).key)
                            replay_db(to_store(t).key) = to_store(t).entry;
                        end
                    end
                    continue; % done with multiuser slot
                end
                % === END MULTIUSER CDMA ===

                % === Single-user per slot (original path) ===
                i = s; if i > cfg.N, i = mod(i-1, cfg.N)+1; end
                node = nodes(i);

                % Preamble modeling (if enabled)
                SNR_node_dB = SNRdB + node_offsets(i);
                if cfg.use_challenge_preamble
                    if ~preamble_success(SNR_node_dB, cfg.preamble_len, cfg.preamble_req_snr_db)
                        rx_bits = zeros(1, cfg.bits_per_slot);
                        FAR=0; FRR=1; success=false; crps_used=0;
                        metrics = metrics_update(metrics, rx_bits, rx_bits, FAR, FRR, success, crps_used);
                        continue;
                    end
                end

                % Optional broadcast base challenge for this slot
                C_shared = [];
                if strcmpi(cfg.challenge_mode,'broadcast')
                    r0 = mod(f-1, size(node.CRP_C,1)) + 1;
                    C_shared = node.CRP_C(r0, :);
                end

                % --- SELECT EFFECTIVE CHALLENGE (fixed length) ---
                reuse_pair = (rand < cfg.replay_reuse_prob) && ~isempty(past_Ceff{i});
                if reuse_pair
                    pick = randi(numel(past_Ceff{i}));
                    C_eff = past_Ceff{i}{pick};
                    replay_ops = replay_ops + 1;
                else
                    % Base challenge
                    if ~isempty(C_shared)
                        C_seed = C_shared;
                    else
                        r = mod(f-1, size(node.CRP_C,1)) + 1;
                        C_seed = node.CRP_C(r, :);
                    end

                    % Nonce selection and mixing
                    if cfg.use_nonce
                        if strcmpi(cfg.nonce_scope,'broadcast')
                            U = randi([0,1], 1, cfg.nonce_len);
                        else
                            U = randi([0,1], 1, cfg.nonce_len);
                        end
                        C_eff = mix_challenge_nonce(C_seed, U, cfg.challenge_len);
                    else
                        C_eff = C_seed;
                    end
                end
                past_Ceff{i}{end+1} = C_eff;

                tx_bits = randi([0,1], 1, cfg.bits_per_slot);
                key = make_key(i, C_eff);

                % Impostor link SNR for THIS slot
                SNR_impostor_dB = decide_impostor_snr(SNR_node_dB, cfg.impostor_snr_db, cfg.impostor_snr_offset_db);

                if strcmpi(cfg.scheme,'CDMA')
                    [rx_bits, FAR, FRR, success, crps_used, obs] = ...
                        txrx_cdma_node(node, C_eff, tx_bits, cfg.L, SNR_node_dB, ...
                                       cfg.threshold, cfg.use_seed_expansion, cfg.accept_ratio);

                    % Force unified decision for FAR/FRR
                    [slot_accept, ~] = decide_cdma_legit(obs.rx, (2*get_puf_bits(node, C_eff, cfg.L)-1), ...
                                                         tx_bits, cfg.L, cfg.threshold, cfg.accept_ratio);
                    FAR = 0;
                    FRR = double(~slot_accept);
                    % (Patch A) DO NOT update metrics here; use the common update below

                    % Replay verify (with channel factor option)
                    if cfg.compute_replay_far && isKey(replay_db, key)
                        attack = replay_db(key);
                        if isequal(attack.C, C_eff)
                            slot_accept_r = verify_cdma_replay_cf(node, C_eff, attack.template, tx_bits, ...
                                                        cfg.L, SNR_node_dB, cfg.threshold, cfg.accept_ratio, ...
                                                        cfg.use_channel_factor, cfg.tau_h, cfg.coherence_prob);
                            replay_trials = replay_trials + 1;
                            if slot_accept_r, replay_accept = replay_accept + 1; end
                        end
                    end

                    % Store CAPTURED template (after replay check is fine here)
                    tmpl_clean = build_cdma_template(node, C_eff, tx_bits, cfg.L);
                    captureSNRdB = decide_capture_snr(SNR_node_dB, cfg.replay_capture_snr_db, cfg.replay_capture_offset_db);
                    tmpl_captured = add_awgn(tmpl_clean, captureSNRdB);
                    replay_db(key) = struct('scheme','CDMA','node',i,'C',C_eff,'L',cfg.L, ...
                                            'tx_bits',tx_bits,'template',tmpl_captured);

                    % True impostor
                    if cfg.compute_impostor_far
                        [acc, trials] = impostor_cdma_vote(nodes, i, C_eff, obs, cfg.threshold, cfg.accept_ratio, SNR_impostor_dB);
                        impostor_accept = impostor_accept + acc;
                        impostor_trials = impostor_trials + trials;
                    end

                    % Overlap diagnostic
                    if cfg.N > 1
                        j = randi(cfg.N-1); if j >= i, j = j + 1; end
                        node_j = nodes(j);
                        R_i = get_puf_bits(node,   C_eff, cfg.L);
                        R_j = get_puf_bits(node_j, C_eff, cfg.L);
                        overlap = 1 - (sum(xor(R_i, R_j)) / cfg.L);
                        overlap_sum = overlap_sum + overlap; overlap_count = overlap_count + 1;
                    end

                else % === CSK path (single-user per slot)
                    [rx_bits, FAR, FRR, success, crps_used, obs] = ...
                        txrx_csk_node(node, C_eff, tx_bits, cfg.M, cfg.L, SNR_node_dB, ...
                                      cfg.threshold, cfg.use_seed_expansion, cfg.accept_ratio);

                    % Unified CSK decision
                    H = hadamard(cfg.L); codebook = H(1:cfg.M, :) ./ sqrt(cfg.L);
                    R_legit   = get_puf_bits(node, C_eff, cfg.M);
                    perm_legit= perm_from_bits(R_legit, cfg.M);
                    P_legit   = codebook(perm_legit, :);
                    bps = log2(cfg.M);
                    sym_idx_true = bi2de(reshape(tx_bits, bps, [])', 'left-msb') + 1;

                    [slot_accept, ~] = decide_csk_legit(obs.rx, P_legit, sym_idx_true, ...
                                                        cfg.L, cfg.threshold, cfg.accept_ratio);
                    FAR = 0;
                    FRR = double(~slot_accept);

                    % Replay verify
                    if cfg.compute_replay_far && isKey(replay_db, key)
                        attack = replay_db(key);
                        if isequal(attack.C, C_eff)
                            slot_accept_r = verify_csk_replay_cf(node, C_eff, attack.template, tx_bits, ...
                                                        cfg.M, cfg.L, SNR_node_dB, cfg.threshold, cfg.accept_ratio, ...
                                                        cfg.use_channel_factor, cfg.tau_h, cfg.coherence_prob);
                            replay_trials = replay_trials + 1;
                            if slot_accept_r, replay_accept = replay_accept + 1; end
                        end
                    end

                    % Store CAPTURED template
                    [tmpl_clean, meta] = build_csk_template(node, C_eff, tx_bits, cfg.M, cfg.L);
                    captureSNRdB = decide_capture_snr(SNR_node_dB, cfg.replay_capture_snr_db, cfg.replay_capture_offset_db);
                    tmpl_captured = add_awgn(tmpl_clean, captureSNRdB);
                    replay_db(key) = struct('scheme','CSK','node',i,'C',C_eff,'M',cfg.M,'L',cfg.L, ...
                                            'tx_bits',tx_bits,'template',tmpl_captured, ...
                                            'perm_idx',meta.perm_idx,'sym_idx',meta.sym_idx);

                    % Perm collision diagnostic & overlap
                    if cfg.N > 1
                        j = randi(cfg.N-1); if j >= i, j = j + 1; end
                        node_j = nodes(j);

                        R_i_L = get_puf_bits(node,   C_eff, cfg.L);
                        R_j_L = get_puf_bits(node_j, C_eff, cfg.L);
                        overlap = 1 - (sum(xor(R_i_L, R_j_L)) / cfg.L);
                        overlap_sum = overlap_sum + overlap; 
                        overlap_count = overlap_count + 1;

                        perm_i = meta.perm_idx; 
                        R_j_M  = get_puf_bits(node_j, C_eff, cfg.M);
                        perm_j = perm_from_bits(R_j_M, cfg.M);

                        perm_count = perm_count + 1;
                        if isequal(perm_i, perm_j)
                            perm_collisions = perm_collisions + 1;
                        end
                    end

                    % True impostor
                    if cfg.compute_impostor_far
                        obs_csk = struct('M',cfg.M,'L',cfg.L,'tx_bits',tx_bits);
                        [acc, trials] = impostor_csk_vote(nodes, i, C_eff, obs_csk, cfg.threshold, cfg.accept_ratio, SNR_impostor_dB);
                        impostor_accept = impostor_accept + acc;
                        impostor_trials = impostor_trials + trials;
                    end
                end

                % Common metrics update for single-user path
                metrics = metrics_update(metrics, rx_bits, tx_bits, FAR, FRR, success, crps_used);
            end
        end

        % --- Aggregate per-SNR
        results.BER(k)  = metrics.bit_errors / max(1, metrics.bits_total);
        results.FAR(k)  = metrics.FAR_sum / max(1, metrics.slots);
        results.FRR(k)  = metrics.FRR_sum / max(1, metrics.slots);
        results.AuthSuccess(k) = metrics.success_count / max(1, metrics.slots);
        results.CRPsPerSlot(k) = metrics.crps_total / max(1, metrics.slots);
        results.mean_overlap_R(k) = overlap_sum / max(1, overlap_count);
        if strcmpi(cfg.scheme,'CSK')
            results.perm_collision_rate(k) = perm_collisions / max(1, perm_count);
        else
            results.perm_collision_rate(k) = NaN;
        end
        total_slots = cfg.frames * cfg.N;
        results.replay_opportunities(k) = replay_ops;
        results.replay_trials(k)       = replay_trials;
        results.FAR_impostor(k) = impostor_accept / max(1, impostor_trials);
        results.FAR_replay(k)   = replay_accept   / max(1, replay_trials);  % CONDITIONAL
        results.ReplayOverall(k)= replay_accept   / max(1, total_slots);    % OVERALL

        if cfg.log_level >= 1
            fprintf('[SNR %5.1f] replay_ops=%d  replay_trials=%d  FAR_replay=%.3f  Overall=%.3f  (nonce=%d, scope=%s)\n', ...
                SNRdB, replay_ops, replay_trials, results.FAR_replay(k), results.ReplayOverall(k), ...
                cfg.use_nonce, cfg.nonce_scope);
        end
    end

    % --- Plots ---
    figure;
    semilogy(cfg.SNRdB_vec, results.BER, '-o','LineWidth',1.5); grid on;
    xlabel('Mean SNR (dB)'); ylabel('BER');
    title(sprintf('BER vs SNR (%s)  (bits/slot=%d, L=%d, acc=%.2f, thr=%.2f, K=%d)', ...
        upper(cfg.scheme), cfg.bits_per_slot, cfg.L, cfg.accept_ratio, cfg.threshold, cfg.K_users_per_slot));

    figure;
    plot(cfg.SNRdB_vec, results.FAR, '-s','LineWidth',1.5); hold on;
    plot(cfg.SNRdB_vec, results.FRR, '-^','LineWidth',1.5);
    grid on; xlabel('Mean SNR (dB)'); ylabel('Rate (0..1)');
    legend('FAR (legit test)','FRR (legit test)','Location','best');
    title(sprintf('Legit FAR/FRR vs SNR (%s)', upper(cfg.scheme)));

    figure;
    plot(cfg.SNRdB_vec, results.FAR_impostor, '-d','LineWidth',1.5); hold on;
    plot(cfg.SNRdB_vec, results.FAR_replay,   '-o','LineWidth',1.5);
    grid on; xlabel('Mean SNR (dB)'); ylabel('Attack FAR (0..1)');
    legend('True Impostor FAR','Replay FAR (conditional)','Location','best');
    title(sprintf('Adversary FAR vs SNR (%s)  (reuse prob=%.2f, nonce=%d)', upper(cfg.scheme), cfg.replay_reuse_prob, cfg.use_nonce));

    figure;
    plot(cfg.SNRdB_vec, results.ReplayOverall, '-o','LineWidth',1.5); grid on;
    xlabel('Mean SNR (dB)'); ylabel('Overall Replay Compromise Rate (0..1)');
    title(sprintf('Overall Replay Risk vs SNR (%s)  (reuse prob=%.2f, nonce=%d)', upper(cfg.scheme), cfg.replay_reuse_prob, cfg.use_nonce));

    if cfg.log_level >= 1
        fprintf('Config: scheme=%s, N=%d, L=%d, M=%d, frames=%d, thr=%.2f, accept_ratio=%.2f, reuse=%.2f, K=%d, SIC=%d, nonce=%d(%s)\n', ...
            upper(cfg.scheme), cfg.N, cfg.L, cfg.M, cfg.frames, cfg.threshold, cfg.accept_ratio, cfg.replay_reuse_prob, cfg.K_users_per_slot, cfg.use_sic, cfg.use_nonce, cfg.nonce_scope);
    end
end

% ===== Helper: Make key (collision-resistant using raw bits) =====
function key = make_key(node_id, C_bits)
    key = sprintf('n%d_C_%s', node_id, sprintf('%d', C_bits(:).'));
end

% ===== Helper: Mix challenge with nonce to keep fixed length =====
function C_eff = mix_challenge_nonce(C_seed, U, target_len)
    if isempty(U)
        C_eff = C_seed; return;
    end
    mask = prg_from_nonce(U, target_len);
    C_eff = xor(logical(C_seed(:).'), mask);
end

function bits = prg_from_nonce(U, nbits)
    s = uint32(2166136261); % FNV offset basis
    for idx = 1:numel(U)
        s = bitxor(s, uint32(U(idx) + idx));
        s = uint32(mod(uint64(s) * uint64(16777619), 2^32));
    end
    bits = false(1, nbits);
    x = s;
    for j = 1:nbits
        x = bitxor(x, bitshift(x, 13, 'uint32'));
        x = bitxor(x, bitshift(x, -17, 'uint32'));
        x = bitxor(x, bitshift(x, 5, 'uint32'));
        bits(j) = bitand(x, uint32(1)) ~= 0;
        s = bitxor(s, x);
        x = bitxor(x, uint32(2654435761));
    end
end

% ===== Helper: Hash bits -> uint32 =====
function h = hash_bits_u32(bits)
    s = uint32(2166136261);
    for k = 1:numel(bits)
        s = bitxor(s, uint32(bits(k) + k));
        s = uint32(mod(uint64(s) * 16777619, 2^32));
    end
    h = s;
end

% ===== Helper: Build CDMA template (noiseless legit) =====
function tmpl = build_cdma_template(node, C_bits, tx_bits, L)
    R = get_puf_bits(node, C_bits, L);
    spread = 2*R - 1;
    N = length(tx_bits);
    tmpl = zeros(1, N*L);
    for i = 1:N
        bit = 2*tx_bits(i) - 1;
        tmpl((i-1)*L+1:i*L) = bit * spread;
    end
end

% ===== Helper: Build CDMA template from a given spread (±1) =====
function tmpl = build_cdma_template_from_spread(spread, tx_bits, L)
    N = numel(tx_bits);
    tmpl = zeros(1, N*L);
    for i = 1:N
        bit = 2*tx_bits(i) - 1;
        tmpl((i-1)*L + (1:L)) = bit * spread;
    end
end

% ===== Helper: Build CSK template (noiseless legit) =====
function [tmpl, meta] = build_csk_template(node, C_bits, tx_bits, M, L)
    H = hadamard(L);
    codebook = H(1:M, :) ./ sqrt(L);
    R = get_puf_bits(node, C_bits, M);
    perm_idx = perm_from_bits(R, M);
    P = codebook(perm_idx, :);
    bps = log2(M); Ns = length(tx_bits)/bps;
    tx_bits_mat = reshape(tx_bits, bps, [])';
    sym_idx = bi2de(tx_bits_mat, 'left-msb') + 1;
    tx_syms = P(sym_idx, :);
    tmpl = reshape(tx_syms.', 1, []);
    meta = struct('perm_idx',perm_idx,'sym_idx',sym_idx);
end

% ===== Helper: CDMA slot decision (unified) =====
function [slot_accept, pass_count] = decide_cdma_legit(rx_vec, spread_legit, tx_bits, L, thr, accept_ratio)
    Nbits = length(tx_bits);
    pass_count = 0;
    for bb = 1:Nbits
        idx = (bb-1)*L + (1:L);
        seg = rx_vec(idx);
        corr_legit = sum(seg .* spread_legit);
        rx_bit = (corr_legit > 0);
        conf = min(1, abs(corr_legit)/L);
        if conf >= thr && (rx_bit == tx_bits(bb)), pass_count = pass_count + 1; end
    end
    need = ceil(accept_ratio * Nbits);
    slot_accept = (pass_count >= need);
end

% ===== Helper: CSK slot decision (unified) =====
function [slot_accept, pass_count] = decide_csk_legit(rx_vec, P_legit, sym_idx_true, L, thr, accept_ratio)
    Ns = numel(sym_idx_true);
    pass_count = 0;
    for s = 1:Ns
        idx = (s-1)*L + (1:L);
        seg = rx_vec(idx);
        corrs = P_legit * seg.';
        [maxc, khat] = max(corrs);
        corr_true = corrs(sym_idx_true(s));
        conf = corr_true / max(maxc, eps);
        if (khat == sym_idx_true(s)) && (conf >= thr), pass_count = pass_count + 1; end
    end
    need = ceil(accept_ratio * Ns);
    slot_accept = (pass_count >= need);
end

% ===== Helper: Verify a CDMA replay attempt with optional channel factor =====
function slot_accept = verify_cdma_replay_cf(node, C_bits, template, tx_bits, L, SNRdB, thr, accept_ratio, use_chf, tau_h, coherence_prob, varargin)
    spread_override = [];
    if ~isempty(varargin), spread_override = varargin{1}; end

    rx_rep = add_awgn(template, SNRdB);

    if ~isempty(spread_override)
        spread_legit = spread_override;
    else
        R_legit = get_puf_bits(node, C_bits, L);
        spread_legit = 2*R_legit - 1;
    end

    [slot_accept_core, ~] = decide_cdma_legit(rx_rep, spread_legit, tx_bits, L, thr, accept_ratio);

    if use_chf
        h_legit = randn(1,length(rx_rep))+1j*randn(1,length(rx_rep));
        phi_legit = chan_features(h_legit, L, length(tx_bits));
        if rand < coherence_prob
            h_rep = randn(1,length(rx_rep))+1j*randn(1,length(rx_rep));
        else
            h_rep = h_legit;
        end
        phi_rep = chan_features(h_rep, L, length(tx_bits));
        s = sim_score(phi_legit, phi_rep);
        slot_accept = slot_accept_core && (s >= tau_h);
    else
        slot_accept = slot_accept_core;
    end
end

% ===== Helper: Verify a CSK replay attempt with optional channel factor =====
function slot_accept = verify_csk_replay_cf(node, C_bits, template, tx_bits, M, L, SNRdB, thr, accept_ratio, use_chf, tau_h, coherence_prob)
    rx_rep = add_awgn(template, SNRdB);

    H = hadamard(L);
    codebook = H(1:M, :) ./ sqrt(L);
    R_legit = get_puf_bits(node, C_bits, M);
    perm_legit = perm_from_bits(R_legit, M);
    P_legit = codebook(perm_legit, :);

    bps = log2(M); Ns = length(tx_bits)/bps;
    sym_true = reshape(tx_bits, bps, [])';
    sym_true = bi2de(sym_true, 'left-msb') + 1;

    [slot_accept_core, ~] = decide_csk_legit(rx_rep, P_legit, sym_true, L, thr, accept_ratio);

    if use_chf
        h_legit = randn(1,length(rx_rep))+1j*randn(1,length(rx_rep));
        phi_legit = chan_features(h_legit, L, Ns);
        if rand < coherence_prob
            h_rep = randn(1,length(rx_rep))+1j*randn(1,length(rx_rep));
        else
            h_rep = h_legit;
        end
        phi_rep = chan_features(h_rep, L, Ns);
        s = sim_score(phi_legit, phi_rep);
        slot_accept = slot_accept_core && (s >= tau_h);
    else
        slot_accept = slot_accept_core;
    end
end

% ===== Helper: Preamble success (logistic proxy) =====
function ok = preamble_success(SNRdB, len, refSNR)
    margin = SNRdB - refSNR;
    p = 1 ./ (1 + exp(-0.9*margin));     % squashed logistic
    ok = rand < p^max(1,len/32);         % longer preambles → stricter
end

% ===== Helper: Decide capture SNR for replay DB =====
function captureSNRdB = decide_capture_snr(SNR_node_dB, replay_capture_snr_db, replay_capture_offset_db)
    if isfinite(replay_capture_snr_db), captureSNRdB = replay_capture_snr_db;
    else, captureSNRdB = SNR_node_dB + replay_capture_offset_db; end
end

% ===== Helper: Decide impostor link SNR =====
function SNR_imp = decide_impostor_snr(SNR_node_dB, impostor_snr_db, impostor_snr_offset_db)
    if isfinite(impostor_snr_db), SNR_imp = impostor_snr_db;
    else, SNR_imp = SNR_node_dB + impostor_snr_offset_db; end
end

% ===== Helper: Add AWGN to a real vector (power-based) =====
function y = add_awgn(x, SNRdB)
    sigP = mean(abs(x).^2);
    noiseP = sigP / (10^(SNRdB/10));
    y = x + sqrt(noiseP/2) * randn(size(x));
end

% ===== Helper: Channel feature extractor (toy) =====
function phi = chan_features(h, L, Nunits)
    if ~isreal(h), hC = h; else, hC = h + 1j*0; end
    H = reshape(hC, L, Nunits);
    mag = abs(H); ph = unwrap(angle(mean(H,1)));
    dph = [0, diff(ph)];
    phi = [mean(mag,'all'), std(mag,0,'all'), mean(abs(dph))];
    phi = phi / (norm(phi)+eps);
end

% ===== Helper: Cosine similarity =====
function s = sim_score(a,b)
    s = abs(a*b') / (norm(a)*norm(b) + eps);
end

% ===== Helper: Naive impostor vote (CDMA) with separate impostor SNR =====
function [acc, trials] = impostor_cdma_vote(nodes, legit_idx, C_bits, obs, thr, accept_ratio, SNR_impostor_dB)
    acc = 0; trials = 0;
    L = obs.L; Nbits = obs.Nbits; tx_bits = obs.tx_bits;

    R_legit = get_puf_bits(nodes(legit_idx), C_bits, L);
    spread_legit = 2*R_legit - 1;

    for j2 = 1:length(nodes)
        if j2 == legit_idx, continue; end

        R_wrong = get_puf_bits(nodes(j2), C_bits, L);
        spread_wrong = 2*R_wrong - 1;

        tx_imp = zeros(1, Nbits*L);
        for bb = 1:Nbits
            bit = 2*tx_bits(bb) - 1;
            tx_imp((bb-1)*L + (1:L)) = bit * spread_wrong;
        end

        sigP = mean(abs(tx_imp).^2);
        noiseP = sigP / (10^(SNR_impostor_dB/10));
        rx_imp = tx_imp + sqrt(noiseP/2) * randn(size(tx_imp));

        pass_count = 0;
        for bb = 1:Nbits
            idx = (bb-1)*L + (1:L);
            seg = rx_imp(idx);
            corr_legit = sum(seg .* spread_legit);
            rx_bit = (corr_legit > 0);
            conf = min(1, abs(corr_legit)/L);
            if conf >= thr && (rx_bit == tx_bits(bb))
                pass_count = pass_count + 1;
            end
        end
        need = ceil(accept_ratio * Nbits);
        trials = trials + 1;
        if pass_count >= need, acc = acc + 1; end
    end
end

% ===== Helper: Naive impostor vote (CSK) =====
function [acc, trials] = impostor_csk_vote(nodes, legit_idx, C_bits, obs, thr, accept_ratio, SNR_impostor_dB)
    acc = 0; trials = 0;

    if isfield(obs,'M'), M = obs.M; else, M = 16; end
    if isfield(obs,'L'), L = obs.L; else, L = 128; end
    tx_bits = obs.tx_bits;
    bps = log2(M);
    Ns = length(tx_bits)/bps;

    H = hadamard(L); codebook = H(1:M, :) ./ sqrt(L);
    R_legit = get_puf_bits(nodes(legit_idx), C_bits, M);
    perm_legit = perm_from_bits(R_legit, M);
    P_legit = codebook(perm_legit, :);

    sym_true = reshape(tx_bits, bps, [])';
    sym_idx  = bi2de(sym_true, 'left-msb') + 1;

    for j2 = 1:length(nodes)
        if j2 == legit_idx, continue; end

        R_wrong   = get_puf_bits(nodes(j2), C_bits, M);
        perm_wrong= perm_from_bits(R_wrong, M);
        P_wrong   = codebook(perm_wrong, :);

        tx_syms_wrong = P_wrong(sym_idx, :);
        tx_imp        = reshape(tx_syms_wrong.', 1, []);

        sigP = mean(abs(tx_imp).^2);
        noiseP = sigP / (10^(SNR_impostor_dB/10));
        rx_imp = tx_imp + sqrt(noiseP/2) * randn(size(tx_imp));

        pass_count = 0;
        for s = 1:Ns
            idxs = (s-1)*L + (1:L);
            segs = rx_imp(idxs);
            corrs = P_legit * segs.';
            [maxc, khat] = max(corrs);
            corr_true = corrs(sym_idx(s));
            conf = corr_true / max(maxc, eps);
            if conf >= thr && (khat == sym_idx(s))
                pass_count = pass_count + 1;
            end
        end
        need = ceil(accept_ratio * Ns);
        trials = trials + 1;
        if pass_count >= need, acc = acc + 1; end
    end
end
